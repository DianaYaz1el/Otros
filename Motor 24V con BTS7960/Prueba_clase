# -*- coding: utf-8 -*-
"""
Control de Motores + Simulador 3D (v2 estable) + HC-SR04 (solo detección)
- Sin frenado automático: NO envía 'detener' al detectar objeto
- Rate limit + coalescing + 3 reintentos antes de desconectar
- Connection: close en cada petición (mejora estabilidad Pico W)
- Mapeo configurable (incluye LR como Adelante/Atrás)
- Opción: 'detener' al soltar (OFF por defecto)
- Indicador de distancia + Alerta objeto (HTTP /distancia)
Autor: diana (integrado)
"""

import math, time, os, threading
import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk, ImageDraw, ImageFilter
import requests

# ----------------------------- Configuración general -----------------------------
TIMEOUT = 1.5        # seg para peticiones HTTP
RATE_LIMIT_MS = 200  # mínimo entre envíos
MAX_FAILS = 3        # errores consecutivos antes de marcar desconectado
ULTRA_POLL_MS = 200  # periodo de lectura de /distancia

# Colores / estilo
SCALE          = 1.0
BG_APP         = "#1f2933"
CARD_TOP       = "#f6f8fb"
CARD_BOT       = "#e5e9f0"
GRID_LINE      = "#cfd6dd"
PLANE_EDGE     = "#b8c2cc"

# Panel de control (izquierda)
CTRL_W, CTRL_H = int(600*SCALE), int(620*SCALE)

# Panel simulador (derecha)
PANEL_SIZE     = int(560*SCALE)
PLANE_MARGIN   = int(PANEL_SIZE*0.07)
PLANE_PERSPECT = 0.22
GRID_N         = 7

# Imagen inicial del carrito (puedes cambiarla)
IMG_PATH = r"C:\Users\diana\Pyton_microcontroladores\ImagenesInterfaces\carrito.png"
SPRITE_W = 160  # ancho en píxeles del sprite del carrito

# Rutas de íconos (si no existen, se dibujan placeholders)
ruta_flecha_arriba    = r"C:\Users\diana\Pyton_microcontroladores\ImagenesInterfaces\up.png"
ruta_flecha_abajo     = r"C:\Users\diana\Pyton_microcontroladores\ImagenesInterfaces\down.png"
ruta_flecha_derecha   = r"C:\Users\diana\Pyton_microcontroladores\ImagenesInterfaces\right.png"
ruta_flecha_izquierda = r"C:\Users\diana\Pyton_microcontroladores\ImagenesInterfaces\left.png"
ruta_detener          = r"C:\Users\diana\Pyton_microcontroladores\ImagenesInterfaces\stop.png"

# ----------------------------- Estado global -----------------------------
estado = {"conectado": False}
MODO_NORMAL = "Normal"
MODO_LR_FA  = "Left/Right = Adelante/Atrás"

# ----------------------------- Comunicación HTTP robusta -----------------------------
class CommandSender:
    """Rate-limit + coalescing + retries + 'Connection: close'."""
    def __init__(self, get_ip_callable, on_soft_error, on_hard_disconnect):
        self.get_ip = get_ip_callable
        self.on_soft_error = on_soft_error
        self.on_hard_disconnect = on_hard_disconnect
        self.lock = threading.Lock()
        self.pending = None
        self.inflight = False
        self.last_ts = 0
        self.fail_count = 0

    def queue(self, cmd):
        with self.lock:
            self.pending = cmd
        self._pump()

    def _pump(self):
        with self.lock:
            if self.inflight or self.pending is None:
                return
            now = time.time() * 1000
            wait_ms = max(0, RATE_LIMIT_MS - int(now - self.last_ts))

        if wait_ms > 0:
            root.after(wait_ms, self._pump)
            return

        def _send():
            with self.lock:
                if self.pending is None:
                    return
                cmd_local = self.pending
                self.pending = None
                self.inflight = True
            try:
                ip = self.get_ip().strip()
                if not ip:
                    raise RuntimeError("IP vacía")
                url = f"http://{ip}/{cmd_local}"
                r = requests.get(url, timeout=TIMEOUT,
                                 headers={"Connection":"close"},
                                 allow_redirects=False)
                if r.status_code == 200:
                    with self.lock:
                        self.fail_count = 0
                        self.last_ts = time.time() * 1000
                    print(f"[OK] {cmd_local}")
                else:
                    print(f"[HTTP {r.status_code}] {cmd_local}")
                    self._register_fail()
            except Exception as e:
                print(f"[ERR] {cmd_local}: {e}")
                self._register_fail()
            finally:
                with self.lock:
                    self.inflight = False
            root.after(0, self._pump)

        threading.Thread(target=_send, daemon=True).start()

    def _register_fail(self):
        with self.lock:
            self.fail_count += 1
            fc = self.fail_count
        if fc < MAX_FAILS:
            self.on_soft_error(f"Intento fallido ({fc}/{MAX_FAILS}).")
        else:
            self.on_hard_disconnect("Múltiples fallos de envío.")

def set_controles(habilitar: bool):
    st = ("normal" if habilitar else "disabled")
    for b in botones_mov:
        b.config(state=st)

def on_conectado():
    estado["conectado"] = True
    lbl_estado.config(text=f"Estado: Conectado a {ent_ip.get().strip()}", fg="green")
    btn_conectar.config(text="Reconectar", state="normal")
    set_controles(True)
    _start_ultra_poll()   # <-- solo leer distancia (sin frenar)

def on_desconectado(msg="No se pudo contactar el dispositivo."):
    estado["conectado"] = False
    lbl_estado.config(text=f"Estado: Desconectado. {msg}", fg="red")
    btn_conectar.config(text="Conectar", state="normal")
    set_controles(False)
    _stop_ultra_poll()

def http_alive(ip, timeout=TIMEOUT):
    for path in ("/ping", "/"):
        try:
            r = requests.get(f"http://{ip}{path}", timeout=timeout,
                             headers={"Connection":"close"}, allow_redirects=False)
            if r.status_code < 500:
                return True
        except requests.exceptions.RequestException:
            pass
    return False

def verificar_conexion():
    ip = ent_ip.get().strip()
    if not ip:
        messagebox.showwarning("IP faltante", "Ingresa la dirección IP del Pico W.")
        return
    lbl_estado.config(text="Estado: Verificando conexión...", fg="orange")
    btn_conectar.config(state="disabled")
    root.after(50, lambda: _hacer_verificacion(ip))

def _hacer_verificacion(ip):
    if http_alive(ip):
        on_conectado()
    else:
        on_desconectado(f"No responde en {ip}. Verifica Wi‑Fi/energía/servidor HTTP.")

def soft_warn(msg):
    if estado["conectado"]:
        lbl_estado.config(text=f"Estado: Conectado — {msg}", fg="orange")

sender = CommandSender(
    get_ip_callable=lambda: ent_ip.get(),
    on_soft_error=soft_warn,
    on_hard_disconnect=lambda m: on_desconectado(f"{m} (revisa señal/energía).")
)

def enviar_comando(cmd):
    if estado["conectado"]:
        sender.queue(cmd)

# ----------------------------- GUI helpers (imágenes y plano) -----------------------------
def _ph_from_image_or_fallback(path, size, kind):
    w, h = size
    try:
        if os.path.exists(path):
            im = Image.open(path).convert("RGBA").resize(size, Image.LANCZOS)
        else:
            raise FileNotFoundError
    except Exception:
        im = Image.new("RGBA", (w, h), (0, 0, 0, 0))
        d = ImageDraw.Draw(im)
        d.rounded_rectangle([1,1,w-2,h-2], radius=min(w,h)//6,
                            fill=(230,236,244,255), outline=(180,190,200,255), width=2)
        if kind in ("up","down","left","right"):
            cx, cy = w//2, h//2; sz = int(min(w,h)*0.35)
            if   kind=="up":    poly=[(cx,cy-sz),(cx-sz,cy+sz),(cx+sz,cy+sz)]
            elif kind=="down":  poly=[(cx,cy+sz),(cx-sz,cy-sz),(cx+sz,cy-sz)]
            elif kind=="left":  poly=[(cx-sz,cy),(cx+sz,cy-sz),(cx+sz,cy+sz)]
            else:               poly=[(cx+sz,cy),(cx-sz,cy-sz),(cx-sz,cy+sz)]
            d.polygon(poly, fill=(52,152,219,255))
        else:
            d.rounded_rectangle([4,4,w-4,h-4], radius=min(w,h)//5, fill=(220,53,69,255))
            txt="DETENER"; tw=d.textlength(txt)
            d.text((w//2 - tw/2, h//2 - 6), txt, fill="white")
    return ImageTk.PhotoImage(im)

def rounded_card(w, h, r, top=CARD_TOP, bottom=CARD_BOT):
    grad = Image.new("RGBA", (w, h), (0,0,0,0))
    top_rgb = tuple(int(top.lstrip("#")[i:i+2], 16) for i in (0,2,4))
    bot_rgb = tuple(int(bottom.lstrip("#")[i:i+2], 16) for i in (0,2,4))
    dr = ImageDraw.Draw(grad)
    for y in range(h):
        t = y/(h-1) if h>1 else 0
        c = tuple(int(top_rgb[i]*(1-t) + bot_rgb[i]*t) for i in range(3))
        dr.line([(0,y),(w,y)], fill=(*c,255))
    mask = Image.new("L", (w,h), 0)
    ImageDraw.Draw(mask).rounded_rectangle([0,0,w-1,h-1], radius=r, fill=255)
    grad.putalpha(mask)
    return ImageTk.PhotoImage(grad)

def lerp(a,b,t): return a+(b-a)*t

def draw_plane(canvas, size, margin, persp=0.22, n=6):
    cx = size//2; w=h=size-2*margin
    top_w = int(w*(1-persp))
    TL=(cx-top_w//2, margin); TR=(cx+top_w//2, margin)
    BL=(cx-w//2,     margin+h); BR=(cx+w//2,     margin+h)
    canvas.create_polygon([*TL,*TR,*BR,*BL], fill="#eef2f7", outline=PLANE_EDGE, width=2)
    for i in range(n):
        t=i/(n-1) if n>1 else 0
        x1,y1 = lerp(TL[0],TR[0],t), lerp(TL[1],TR[1],t)
        x2,y2 = lerp(BL[0],BR[0],t), lerp(BL[1],BR[1],t)
        canvas.create_line(x1,y1,x2,y2, fill=GRID_LINE, width=1)
        x3,y3 = lerp(TL[0],BL[0],t), lerp(TL[1],BL[1],t)
        x4,y4 = lerp(TR[0],BR[0],t), lerp(TR[1],BR[1],t)
        canvas.create_line(x3,y3,x4,y4, fill=GRID_LINE, width=1)
    return {"TL":TL,"TR":TR,"BL":BL,"BR":BR}

def bilinear(p00,p10,p01,p11,u,v):
    x = p00[0]*(1-u)*(1-v) + p10[0]*u*(1-v) + p01[0]*(1-u)*v + p11[0]*u*v
    y = p00[1]*(1-u)*(1-v) + p10[1]*u*(1-v) + p01[1]*(1-u)*v + p11[1]*u*v
    return x,y

def load_car_sprite(path, w):
    try:
        if not os.path.exists(path):
            raise FileNotFoundError(f"No existe: {path}")
        im = Image.open(path).convert("RGBA")
        ratio = w / float(im.width)
        im = im.resize((w, int(im.height*ratio)), Image.LANCZOS)
    except Exception as e:
        print("No pude cargar la imagen del carrito:", e)
        im = Image.new("RGBA", (w, w), (0,0,0,0))
        d = ImageDraw.Draw(im)
        d.ellipse([2,2,w-2,w-2], fill=(52,152,219,255))
    halo_size = int(max(im.width, im.height)*1.35)
    halo = Image.new("RGBA", (halo_size, halo_size), (0,0,0,0))
    d = ImageDraw.Draw(halo)
    d.ellipse([0,0,halo_size-1,halo_size-1], fill=(52,152,219,90))
    halo = halo.filter(ImageFilter.GaussianBlur(int(halo_size*0.22)))
    return im, halo

def sprite_from_angle(img, ang_deg):
    rotated = img.rotate(-ang_deg, resample=Image.BICUBIC, expand=True)
    return ImageTk.PhotoImage(rotated), rotated.width, rotated.height

# ----------------------------- Ventana principal -----------------------------
root = tk.Tk()
root.title("Control de Motores + Simulador 3D (v2) + HC-SR04 (solo detección)")
root.configure(bg=BG_APP)
root.geometry(f"{int(1220*SCALE)}x{int(900*SCALE)}")

# Encabezado
frm_top = tk.Frame(root, padx=10, pady=10, bg=BG_APP)
frm_top.pack(fill="x")

tk.Label(frm_top, text="IP del Pico W:", fg="white", bg=BG_APP).grid(row=0, column=0, sticky="w")
ent_ip = tk.Entry(frm_top, width=18)
ent_ip.grid(row=0, column=1, padx=(6,10))
ent_ip.insert(0, "192.168.0.101")

btn_conectar = tk.Button(frm_top, text="Conectar", command=verificar_conexion)
btn_conectar.grid(row=0, column=2, padx=(0,10))

lbl_estado = tk.Label(frm_top, text="Estado: Desconectado", fg="red", bg=BG_APP)
lbl_estado.grid(row=1, column=0, columnspan=3, sticky="w", pady=(8,0))

# Opciones
opciones = tk.Frame(frm_top, bg=BG_APP)
opciones.grid(row=2, column=0, columnspan=3, sticky="w", pady=(6,0))
tk.Label(opciones, text="Mapa de teclas:", fg="white", bg=BG_APP).grid(row=0, column=0, sticky="w")

modo_var = tk.StringVar(value=MODO_LR_FA)
modo_menu = tk.OptionMenu(opciones, modo_var, MODO_NORMAL, MODO_LR_FA)
modo_menu.grid(row=0, column=1, padx=(6,12))

invertir_lr_var = tk.BooleanVar(value=False)
tk.Checkbutton(opciones, text="Invertir LR (adelante↔atrás)", variable=invertir_lr_var,
               fg="white", bg=BG_APP, selectcolor=BG_APP, activebackground=BG_APP).grid(row=0, column=2, padx=(6,12))

detener_release_var = tk.BooleanVar(value=False)
tk.Checkbutton(opciones, text="Enviar 'detener' al soltar", variable=detener_release_var,
               fg="white", bg=BG_APP, selectcolor=BG_APP, activebackground=BG_APP).grid(row=0, column=3, padx=(6,12))

tk.Label(opciones, text="(Rate‑limit 200ms • 3 reintentos)", fg="#cbd5e1", bg=BG_APP).grid(row=0, column=4)

# Contenedor 2 columnas
frm_mid = tk.Frame(root, bg=BG_APP)
frm_mid.pack(fill="both", expand=True, padx=10, pady=10)

# -------- Panel de control (izquierda) --------
frm_left = tk.Frame(frm_mid, width=CTRL_W, height=CTRL_H, bg=BG_APP)
frm_left.pack(side="left", padx=(0,10), pady=5)
frm_left.pack_propagate(False)

ctrl_canvas = tk.Canvas(frm_left, width=CTRL_W, height=CTRL_H-20, bg=BG_APP, highlightthickness=0)
ctrl_canvas.pack()
card_ctrl = rounded_card(CTRL_W, CTRL_H-20, int(22*SCALE))
ctrl_canvas.create_image(0, 0, image=card_ctrl, anchor="nw")
ctrl_canvas._assets = [card_ctrl]

flecha_arriba  = _ph_from_image_or_fallback(ruta_flecha_arriba,    (100,100), "up")
flecha_abajo   = _ph_from_image_or_fallback(ruta_flecha_abajo,     (100,100), "down")
flecha_derecha = _ph_from_image_or_fallback(ruta_flecha_derecha,   (100,100), "right")
flecha_izqda   = _ph_from_image_or_fallback(ruta_flecha_izquierda, (100,100), "left")
img_detener    = _ph_from_image_or_fallback(ruta_detener,          (400,100), "stop")

btn_up    = tk.Button(frm_left, image=flecha_arriba,  state="disabled", relief="flat", bd=0, cursor="hand2")
btn_down  = tk.Button(frm_left, image=flecha_abajo,   state="disabled", relief="flat", bd=0, cursor="hand2")
btn_right = tk.Button(frm_left, image=flecha_derecha, state="disabled", relief="flat", bd=0, cursor="hand2")
btn_left  = tk.Button(frm_left, image=flecha_izqda,   state="disabled", relief="flat", bd=0, cursor="hand2")
btn_stop  = tk.Button(frm_left, image=img_detener,    relief="flat", bd=0, cursor="hand2",
                      command=lambda: stop_all(send_hw=True))

btn_up.place(x=250, y=120)
btn_down.place(x=250, y=320)
btn_right.place(x=400, y=220)
btn_left.place(x=100, y=220)
btn_stop.place(x=90, y=470)

botones_mov = [btn_up, btn_down, btn_right, btn_left, btn_stop]
set_controles(False)

# -------- Simulador 3D (derecha) --------
frm_right = tk.Frame(frm_mid, bg=BG_APP)
frm_right.pack(side="left", padx=(10,0), pady=5)

btn_img = tk.Button(frm_right, text="Elegir imagen del carrito")
btn_img.pack(pady=(6,0))

cnv = tk.Canvas(frm_right, width=PANEL_SIZE, height=PANEL_SIZE, bg=BG_APP, highlightthickness=0)
cnv.pack(pady=8)

card_sim = rounded_card(PANEL_SIZE, PANEL_SIZE, int(22*SCALE))
cnv.create_image(0,0, image=card_sim, anchor="nw")
plane = draw_plane(cnv, PANEL_SIZE, PLANE_MARGIN, persp=PLANE_PERSPECT, n=GRID_N)
cnv._assets = [card_sim]

PLANE_CX = int((plane["TL"][0]+plane["TR"][0]+plane["BL"][0]+plane["BR"][0])/4)
PLANE_CY = int((plane["TL"][1]+plane["TR"][1]+plane["BL"][1]+plane["BR"][1])/4)

base_car_img, halo_img = load_car_sprite(IMG_PATH, SPRITE_W)
halo_ph  = ImageTk.PhotoImage(halo_img)
halo_id  = cnv.create_image(PLANE_CX, PLANE_CY, image=halo_ph)
cnv._assets.append(halo_ph)

car_ang = 0.0
car_img_ph, car_w, car_h = sprite_from_angle(base_car_img, car_ang)
car_id = cnv.create_image(PLANE_CX, PLANE_CY, image=car_img_ph)

info = tk.Label(frm_right, text="Flechas: mover/girar  |  Espacio: detener/soltar",
                fg="white", bg=BG_APP, font=("Segoe UI", 11))
info.pack(pady=(4,8))

def elegir_imagen():
    global base_car_img, halo_img, car_img_ph, car_w, car_h
    path = filedialog.askopenfilename(
        title="Elige la imagen del carrito",
        filetypes=[("Imágenes", "*.png;*.jpg;*.jpeg;*.bmp;*.webp")]
    )
    if not path: return
    base_car_img, halo_img = load_car_sprite(path, SPRITE_W)
    halo_ph_new = ImageTk.PhotoImage(halo_img)
    cnv.itemconfig(halo_id, image=halo_ph_new)
    cnv._assets.append(halo_ph_new)
    car_img_ph, car_w, car_h = sprite_from_angle(base_car_img, car_ang)
    cnv.itemconfig(car_id, image=car_img_ph)

btn_img.config(command=elegir_imagen)

# ---------- Distancia + Alerta objeto (sin frenar) ----------
ultra_ui = tk.Frame(frm_right, bg=BG_APP)
ultra_ui.pack(pady=(0,6))

tk.Label(ultra_ui, text="Distancia:", fg="white", bg=BG_APP).grid(row=0, column=0, sticky="w")
dist_text = tk.StringVar(value="— cm")
lbl_dist = tk.Label(ultra_ui, textvariable=dist_text, fg="#38bdf8", bg=BG_APP, font=("Segoe UI", 14, "bold"))
lbl_dist.grid(row=0, column=1, padx=(6,14))

alerta_var = tk.BooleanVar(value=True)  # habilitar alerta visual/beep
tk.Checkbutton(ultra_ui, text="Alerta objeto <", variable=alerta_var,
               fg="white", bg=BG_APP, selectcolor=BG_APP, activebackground=BG_APP)\
  .grid(row=0, column=2)

umbral_var = tk.IntVar(value=25)  # cm
umbral_entry = tk.Entry(ultra_ui, width=4, textvariable=umbral_var)
umbral_entry.grid(row=0, column=3)
tk.Label(ultra_ui, text="cm", fg="white", bg=BG_APP).grid(row=0, column=4, padx=(2,8))

beep_var = tk.BooleanVar(value=False)
tk.Checkbutton(ultra_ui, text="Beep", variable=beep_var,
               fg="white", bg=BG_APP, selectcolor=BG_APP, activebackground=BG_APP)\
  .grid(row=0, column=5)

# Estado grande LIBRE / OBJETO
estado_ui = tk.Frame(frm_right, bg=BG_APP)
estado_ui.pack(pady=(0,10))
tk.Label(estado_ui, text="Estado:", fg="white", bg=BG_APP).grid(row=0, column=0, sticky="w")
obj_text = tk.StringVar(value="Libre")
lbl_objeto = tk.Label(estado_ui, textvariable=obj_text, fg="#22c55e", bg=BG_APP, font=("Segoe UI", 16, "bold"))
lbl_objeto.grid(row=0, column=1, padx=(8,0), sticky="w")

ultra_job = None
objeto_presente = False  # para detectar cambios y hacer beep solo en flanco

def _poll_ultrasonico():
    global ultra_job, objeto_presente
    if not estado["conectado"]:
        dist_text.set("— cm"); lbl_dist.config(fg="#cbd5e1")
        obj_text.set("Libre"); lbl_objeto.config(fg="#94d82d")  # verde suave
        objeto_presente = False
        ultra_job = root.after(ULTRA_POLL_MS, _poll_ultrasonico)
        return

    ip = ent_ip.get().strip()
    try:
        r = requests.get(f"http://{ip}/distancia", timeout=TIMEOUT, headers={"Connection":"close"})
        d = None
        try:
            j = r.json(); d = j.get("cm", None)
        except ValueError:
            txt = r.text.strip()
            if txt and txt.lower() != "null":
                d = float(txt)

        if isinstance(d, (int, float)):
            dist_text.set(f"{d:.0f} cm")
            # Estado visual de distancia
            lbl_dist.config(fg="#38bdf8")  # celeste por defecto
            # Lógica de alerta (SIN frenar)
            activo = bool(alerta_var.get())
            detecta = (d <= umbral_var.get()) if activo else False
            if detecta != objeto_presente and detecta and beep_var.get():
                root.bell()  # beep solo al entrar a OBJETO
            objeto_presente = detecta
            if detecta:
                obj_text.set("OBJETO"); lbl_objeto.config(fg="#f43f5e")  # rojo
            else:
                obj_text.set("Libre");  lbl_objeto.config(fg="#22c55e")  # verde
        else:
            dist_text.set("— cm"); lbl_dist.config(fg="#cbd5e1")
            obj_text.set("Libre");  lbl_objeto.config(fg="#94d82d")
            objeto_presente = False
    except requests.exceptions.RequestException:
        dist_text.set("— cm"); lbl_dist.config(fg="#cbd5e1")
        obj_text.set("Libre");  lbl_objeto.config(fg="#94d82d")
        objeto_presente = False

    ultra_job = root.after(ULTRA_POLL_MS, _poll_ultrasonico)

def _start_ultra_poll():
    global ultra_job
    if ultra_job is None:
        ultra_job = root.after(100, _poll_ultrasonico)

def _stop_ultra_poll():
    global ultra_job
    if ultra_job is not None:
        root.after_cancel(ultra_job)
        ultra_job = None
    dist_text.set("— cm"); lbl_dist.config(fg="#cbd5e1")
    obj_text.set("Libre");  lbl_objeto.config(fg="#94d82d")

# ------------------ Lógica de simulación y entrada ------------------
teclas = set()
MOV_KEYS = ("Up","Down","Left","Right")

u, v = 0.5, 0.5
lin_speed = 0.0
ang_speed = 0.0
V_FWD, V_BACK, W_LEFT, W_RIGHT = 0.35, -0.35, +90.0, -90.0

def get_cmd_for_key(k):
    modo = modo_var.get()
    inv = invertir_lr_var.get()
    if modo == MODO_LR_FA:
        if k == "Left":   return "atras"    if inv else "adelante"
        if k == "Right":  return "adelante" if inv else "atras"
        if k == "Up":     return "girar_izquierda"
        if k == "Down":   return "girar_derecha"
    else:
        if k == "Up":     return "adelante"
        if k == "Down":   return "atras"
        if k == "Left":   return "girar_izquierda"
        if k == "Right":  return "girar_derecha"
    if k == "space":      return "detener"
    return None

def update_speeds():
    global lin_speed, ang_speed
    modo = modo_var.get()
    if modo == MODO_LR_FA:
        lin_speed = (V_FWD if "Left" in teclas else 0.0) + (V_BACK if "Right" in teclas else 0.0)
        ang_speed = (W_LEFT if "Up" in teclas else 0.0) + (W_RIGHT if "Down" in teclas else 0.0)
        if invertir_lr_var.get():
            lin_speed = -lin_speed
    else:
        lin_speed = (V_FWD if "Up" in teclas else 0.0) + (V_BACK if "Down" in teclas else 0.0)
        ang_speed = (W_LEFT if "Left" in teclas else 0.0) + (W_RIGHT if "Right" in teclas else 0.0)

def stop_all(send_hw=True):
    teclas.clear()
    if send_hw: enviar_comando("detener")

def key_down(e):
    k = e.keysym
    if k in MOV_KEYS:
        if k not in teclas:
            teclas.add(k)
            cmd = get_cmd_for_key(k)
            if cmd: enviar_comando(cmd)
    elif k == "space":
        stop_all(send_hw=True)

def key_up(e):
    k = e.keysym
    if k in MOV_KEYS and k in teclas:
        teclas.remove(k)
        if detener_release_var.get():
            enviar_comando("detener")

root.bind("<KeyPress>", key_down)
root.bind("<KeyRelease>", key_up)

def _btn_press(k):
    if k not in teclas:
        teclas.add(k)
        cmd = get_cmd_for_key(k)
        if cmd: enviar_comando(cmd)

def _btn_release(k):
    if k in teclas:
        teclas.remove(k)
        if detener_release_var.get():
            enviar_comando("detener")

btn_up.bind("<ButtonPress-1>",   lambda _e: _btn_press("Up"))
btn_up.bind("<ButtonRelease-1>", lambda _e: _btn_release("Up"))
btn_down.bind("<ButtonPress-1>",   lambda _e: _btn_press("Down"))
btn_down.bind("<ButtonRelease-1>", lambda _e: _btn_release("Down"))
btn_left.bind("<ButtonPress-1>",   lambda _e: _btn_press("Left"))
btn_left.bind("<ButtonRelease-1>", lambda _e: _btn_release("Left"))
btn_right.bind("<ButtonPress-1>",   lambda _e: _btn_press("Right"))
btn_right.bind("<ButtonRelease-1>", lambda _e: _btn_release("Right"))

# Bucle del simulador
_last = time.time()
def step():
    global u, v, car_ang, car_img_ph, car_w, car_h, _last
    now = time.time(); dt = now - _last; _last = now
    update_speeds()
    if lin_speed or ang_speed:
        th = math.radians(car_ang)
        du = math.sin(th) * (lin_speed * dt)
        dv = -math.cos(th) * (lin_speed * dt)
        u = max(0.02, min(0.98, u + du))
        v = max(0.02, min(0.98, v + dv))
        car_ang = (car_ang + ang_speed * dt) % 360
        car_img_ph, car_w, car_h = sprite_from_angle(base_car_img, car_ang)
        cnv.itemconfig(car_id, image=car_img_ph)
    TL, TR, BL, BR = plane["TL"], plane["TR"], plane["BL"], plane["BR"]
    px, py = bilinear(TL, TR, BL, BR, u, v)
    cnv.coords(halo_id, px, py)
    cnv.coords(car_id, px, py)
    root.after(16, step)

root.after(16, step)
root.mainloop()
