# -*- coding: utf-8 -*-
"""
Control de Motores + Simulador 3D (Wi-Fi o Bluetooth) + HC-SR04 (solo detección)
- Misma interfaz que la tuya; arriba eliges Wi-Fi o Bluetooth (HC-05/HC-06)
- HTTP: /adelante /atras /girar_izquierda /girar_derecha /detener /velocidad?v= /distancia
- BT:   envía líneas de texto con los mismos comandos; 'distancia' responde JSON {"cm":..}
Autor: diana (integrado) + adaptación
"""

import sys, asyncio
if sys.platform.startswith("win"):
    # Evita el "Task was destroyed..." con Tkinter en Windows + Spyder/IPython
    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

import math, time, os, threading, json
import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk, ImageDraw, ImageFilter
import requests

# ---- Bluetooth (pyserial) ----
try:
    import serial, serial.tools.list_ports
except Exception:
    serial = None

# ----------------------------- Configuración general -----------------------------
TIMEOUT = 1.5        # seg para peticiones HTTP / lecturas BT
RATE_LIMIT_MS = 200  # mínimo entre envíos
MAX_FAILS = 3        # errores consecutivos antes de marcar desconectado
ULTRA_POLL_MS = 250  # periodo de lectura de distancia

# Colores / estilo
SCALE          = 1.0
BG_APP         = "#1f2933"
CARD_TOP       = "#f6f8fb"
CARD_BOT       = "#e5e9f0"
GRID_LINE      = "#cfd6dd"
PLANE_EDGE     = "#b8c2cc"

# Panel de control (izquierda)
CTRL_W, CTRL_H = int(600*SCALE), int(620*SCALE)

# Panel simulador (derecha)
PANEL_SIZE     = int(560*SCALE)
PLANE_MARGIN   = int(PANEL_SIZE*0.07)
PLANE_PERSPECT = 0.22
GRID_N         = 7

# Imagen inicial del carrito (puedes cambiarla)
IMG_PATH = r"C:\Users\diana\Pyton_microcontroladores\ImagenesInterfaces\carrito.png"
SPRITE_W = 160

# Íconos
ruta_flecha_arriba    = r"C:\Users\diana\Pyton_microcontroladores\ImagenesInterfaces\up.png"
ruta_flecha_abajo     = r"C:\Users\diana\Pyton_microcontroladores\ImagenesInterfaces\down.png"
ruta_flecha_derecha   = r"C:\Users\diana\Pyton_microcontroladores\ImagenesInterfaces\right.png"
ruta_flecha_izquierda = r"C:\Users\diana\Pyton_microcontroladores\ImagenesInterfaces\left.png"
ruta_detener          = r"C:\Users\diana\Pyton_microcontroladores\ImagenesInterfaces\stop.png"

# ----------------------------- Estado global -----------------------------
estado = {"conectado": False, "modo":"Wi-Fi"}
MODO_NORMAL = "Normal"
MODO_LR_FA  = "Left/Right = Adelante/Atrás"

# ----------------------------- Transports (Wi-Fi / BT) -----------------------------
class HttpTransport:
    def __init__(self, get_ip):
        self.get_ip = get_ip
    def connect(self):
        return self.is_alive()
    def is_alive(self):
        ip = self.get_ip().strip()
        if not ip: return False
        for path in ("/ping","/"):
            try:
                r = requests.get(f"http://{ip}{path}", timeout=TIMEOUT,
                                 headers={"Connection":"close"}, allow_redirects=False)
                if r.status_code < 500:
                    return True
            except requests.exceptions.RequestException:
                pass
        return False
    def send(self, cmd):
        ip = self.get_ip().strip()
        if not ip: raise RuntimeError("IP vacía")
        r = requests.get(f"http://{ip}/{cmd}", timeout=TIMEOUT,
                         headers={"Connection":"close"}, allow_redirects=False)
        return r.status_code == 200
    def read_distance(self):
        ip = self.get_ip().strip()
        r = requests.get(f"http://{ip}/distancia", timeout=TIMEOUT,
                         headers={"Connection":"close"})
        try:
            j = r.json(); d = j.get("cm", None)
            return None if d is None else float(d)
        except ValueError:
            txt = r.text.strip()
            if txt and txt.lower() != "null":
                return float(txt)
            return None

class BtTransport:
    def __init__(self, get_port, baud_getter=lambda:9600):
        self.get_port = get_port
        self.get_baud = baud_getter
        self.ser = None
    def connect(self):
        if serial is None:
            raise RuntimeError("pyserial no instalado. Ejecuta: pip install pyserial")
        port = self.get_port().strip()
        if not port: return False
        self.close()
        self.ser = serial.Serial(port, self.get_baud(), timeout=TIMEOUT)
        # saludar y limpiar buffer
        try:
            self.ser.write(b"ping\n")
        except Exception:
            pass
        return True
    def is_alive(self):
        return self.ser is not None and self.ser.is_open
    def send(self, cmd):
        if not self.is_alive(): return False
        line = (cmd+"\n").encode("utf-8")
        self.ser.write(line)
        return True
    def read_distance(self):
        if not self.is_alive(): return None
        self.ser.reset_input_buffer()
        self.ser.write(b"distancia\n")
        line = self.ser.readline().decode(errors="ignore").strip()
        # acepta {"cm":xx} o número suelto
        if not line:
            return None
        try:
            j = json.loads(line)
            d = j.get("cm", None)
            return None if d is None else float(d)
        except Exception:
            try:
                return float(line)
            except Exception:
                return None
    def close(self):
        if self.ser:
            try: self.ser.close()
            except: pass
            self.ser = None

# instancia actual (se setea al conectar)
transport = None

# ----------------------------- Comunicación robusta (rate-limit) -----------------------------
class CommandSender:
    """Rate-limit + coalescing + retries."""
    def __init__(self, sender_callable, on_soft_error, on_hard_disconnect):
        self._send = sender_callable
        self.on_soft_error = on_soft_error
        self.on_hard_disconnect = on_hard_disconnect
        self.lock = threading.Lock()
        self.pending = None
        self.inflight = False
        self.last_ts = 0
        self.fail_count = 0

    def queue(self, cmd):
        with self.lock:
            self.pending = cmd
        self._pump()

    def _pump(self):
        with self.lock:
            if self.inflight or self.pending is None:
                return
            now = time.time() * 1000
            wait_ms = max(0, RATE_LIMIT_MS - int(now - self.last_ts))
        if wait_ms > 0:
            root.after(wait_ms, self._pump); return

        def _send():
            with self.lock:
                if self.pending is None: return
                cmd_local = self.pending; self.pending=None; self.inflight=True
            ok = False
            try:
                ok = self._send(cmd_local)
            except Exception as e:
                print("[ERR]", e)
            with self.lock:
                if ok:
                    self.fail_count = 0
                    self.last_ts = time.time() * 1000
                else:
                    self.fail_count += 1
                    if self.fail_count < MAX_FAILS:
                        self.on_soft_error(f"Intento fallido ({self.fail_count}/{MAX_FAILS}).")
                    else:
                        self.on_hard_disconnect("Múltiples fallos de envío.")
                self.inflight=False
            root.after(0, self._pump)
        threading.Thread(target=_send, daemon=True).start()

def soft_warn(msg):
    if estado["conectado"]:
        lbl_estado.config(text=f"Estado: Conectado — {msg}", fg="orange")

def on_desconectado(msg="No se pudo contactar el dispositivo."):
    global transport
    estado["conectado"] = False
    lbl_estado.config(text=f"Estado: Desconectado. {msg}", fg="red")
    btn_conectar.config(text="Conectar", state="normal")
    set_controles(False)
    _stop_ultra_poll()
    if isinstance(transport, BtTransport):
        transport.close()
    transport = None

def on_conectado_ok():
    estado["conectado"] = True
    lbl_estado.config(text=f"Estado: Conectado ({estado['modo']})", fg="green")
    btn_conectar.config(text="Reconectar", state="normal")
    set_controles(True)
    _start_ultra_poll()

# ----------------------------- GUI helpers (imágenes y plano) -----------------------------
def _ph_from_image_or_fallback(path, size, kind):
    w, h = size
    try:
        if os.path.exists(path):
            im = Image.open(path).convert("RGBA").resize(size, Image.LANCZOS)
        else:
            raise FileNotFoundError
    except Exception:
        im = Image.new("RGBA", (w, h), (0, 0, 0, 0))
        d = ImageDraw.Draw(im)
        d.rounded_rectangle([1,1,w-2,h-2], radius=min(w,h)//6,
                            fill=(230,236,244,255), outline=(180,190,200,255), width=2)
        if kind in ("up","down","left","right"):
            cx, cy = w//2, h//2; sz = int(min(w,h)*0.35)
            if   kind=="up":    poly=[(cx,cy-sz),(cx-sz,cy+sz),(cx+sz,cy+sz)]
            elif kind=="down":  poly=[(cx,cy+sz),(cx-sz,cy-sz),(cx+sz,cy-sz)]
            elif kind=="left":  poly=[(cx-sz,cy),(cx+sz,cy-sz),(cx+sz,cy+sz)]
            else:               poly=[(cx+sz,cy),(cx-sz,cy-sz),(cx-sz,cy+sz)]
            d.polygon(poly, fill=(52,152,219,255))
        else:
            d.rounded_rectangle([4,4,w-4,h-4], radius=min(w,h)//5, fill=(220,53,69,255))
            txt="DETENER"; tw=d.textlength(txt)
            d.text((w//2 - tw/2, h//2 - 6), txt, fill="white")
    return ImageTk.PhotoImage(im)

def rounded_card(w, h, r, top=CARD_TOP, bottom=CARD_BOT):
    grad = Image.new("RGBA", (w, h), (0,0,0,0))
    top_rgb = tuple(int(top.lstrip("#")[i:i+2], 16) for i in (0,2,4))
    bot_rgb = tuple(int(bottom.lstrip("#")[i:i+2], 16) for i in (0,2,4))
    dr = ImageDraw.Draw(grad)
    for y in range(h):
        t = y/(h-1) if h>1 else 0
        c = tuple(int(top_rgb[i]*(1-t) + bot_rgb[i]*t) for i in range(3))
        dr.line([(0,y),(w,y)], fill=(*c,255))
    mask = Image.new("L", (w,h), 0)
    ImageDraw.Draw(mask).rounded_rectangle([0,0,w-1,h-1], radius=r, fill=255)
    grad.putalpha(mask)
    return ImageTk.PhotoImage(grad)

def lerp(a,b,t): return a+(b-a)*t

def draw_plane(canvas, size, margin, persp=0.22, n=6):
    cx = size//2; w=h=size-2*margin
    top_w = int(w*(1-persp))
    TL=(cx-top_w//2, margin); TR=(cx+top_w//2, margin)
    BL=(cx-w//2,     margin+h); BR=(cx+w//2,     margin+h)
    canvas.create_polygon([*TL,*TR,*BR,*BL], fill="#eef2f7", outline=PLANE_EDGE, width=2)
    for i in range(n):
        t=i/(n-1) if n>1 else 0
        x1,y1 = lerp(TL[0],TR[0],t), lerp(TL[1],TR[1],t)
        x2,y2 = lerp(BL[0],BR[0],t), lerp(BL[1],BR[1],t)
        canvas.create_line(x1,y1,x2,y2, fill=GRID_LINE, width=1)
        x3,y3 = lerp(TL[0],BL[0],t), lerp(TL[1],BL[1],t)
        x4,y4 = lerp(TR[0],BR[0],t), lerp(TR[1],BR[1],t)
        canvas.create_line(x3,y3,x4,y4, fill=GRID_LINE, width=1)
    return {"TL":TL,"TR":TR,"BL":BL,"BR":BR}

def bilinear(p00,p10,p01,p11,u,v):
    x = p00[0]*(1-u)*(1-v) + p10[0]*u*(1-v) + p01[0]*(1-u)*v + p11[0]*u*v
    y = p00[1]*(1-u)*(1-v) + p10[1]*u*(1-v) + p01[1]*(1-u)*v + p11[1]*u*v
    return x,y

def load_car_sprite(path, w):
    try:
        if not os.path.exists(path):
            raise FileNotFoundError(f"No existe: {path}")
        im = Image.open(path).convert("RGBA")
        ratio = w / float(im.width)
        im = im.resize((w, int(im.height*ratio)), Image.LANCZOS)
    except Exception as e:
        print("No pude cargar la imagen del carrito:", e)
        im = Image.new("RGBA", (w, w), (0,0,0,0))
        d = ImageDraw.Draw(im)
        d.ellipse([2,2,w-2,w-2], fill=(52,152,219,255))
    halo_size = int(max(im.width, im.height)*1.35)
    halo = Image.new("RGBA", (halo_size, halo_size), (0,0,0,0))
    d = ImageDraw.Draw(halo)
    d.ellipse([0,0,halo_size-1,halo_size-1], fill=(52,152,219,90))
    halo = halo.filter(ImageFilter.GaussianBlur(int(halo_size*0.22)))
    return im, halo

def sprite_from_angle(img, ang_deg):
    rotated = img.rotate(-ang_deg, resample=Image.BICUBIC, expand=True)
    return ImageTk.PhotoImage(rotated), rotated.width, rotated.height

# ----------------------------- Ventana principal -----------------------------
root = tk.Tk()
root.title("Control Wi-Fi / Bluetooth + Simulador 3D + HC-SR04")
root.configure(bg=BG_APP)
root.geometry(f"{int(1220*SCALE)}x{int(920*SCALE)}")

# Encabezado
frm_top = tk.Frame(root, padx=10, pady=10, bg=BG_APP)
frm_top.pack(fill="x")

# Selector Wi-Fi / BT
tk.Label(frm_top, text="Modo:", fg="white", bg=BG_APP)\
  .grid(row=0, column=0, sticky="w")
modo_conn = tk.StringVar(value="Wi-Fi")
tk.OptionMenu(frm_top, modo_conn, "Wi-Fi", "Bluetooth").grid(row=0, column=1, sticky="w", padx=(6,10))

# Wi-Fi
tk.Label(frm_top, text="IP del Pico W:", fg="white", bg=BG_APP).grid(row=0, column=2, sticky="e")
ent_ip = tk.Entry(frm_top, width=16); ent_ip.grid(row=0, column=3, padx=(6,12))
ent_ip.insert(0, "192.168.0.101")

# Bluetooth
tk.Label(frm_top, text="COM:", fg="white", bg=BG_APP).grid(row=0, column=4, sticky="e")
ent_com = tk.Entry(frm_top, width=8); ent_com.grid(row=0, column=5, padx=(6,8))
# autollenar puerto si existe pyserial
if serial:
    ports = [p.device for p in serial.tools.list_ports.comports()]
    if ports:
        ent_com.insert(0, ports[0])
else:
    ent_com.insert(0, "COMx")

btn_conectar = tk.Button(frm_top, text="Conectar")
btn_conectar.grid(row=0, column=6, padx=(8,10))

lbl_estado = tk.Label(frm_top, text="Estado: Desconectado", fg="red", bg=BG_APP)
lbl_estado.grid(row=1, column=0, columnspan=7, sticky="w", pady=(8,0))

# Opciones
opciones = tk.Frame(frm_top, bg=BG_APP)
opciones.grid(row=2, column=0, columnspan=7, sticky="w", pady=(6,0))
tk.Label(opciones, text="Mapa de teclas:", fg="white", bg=BG_APP).grid(row=0, column=0, sticky="w")

MODO_NORMAL = "Normal"; MODO_LR_FA = "Left/Right = Adelante/Atrás"
modo_var = tk.StringVar(value=MODO_LR_FA)
tk.OptionMenu(opciones, modo_var, MODO_NORMAL, MODO_LR_FA).grid(row=0, column=1, padx=(6,12))

invertir_lr_var = tk.BooleanVar(value=False)
tk.Checkbutton(opciones, text="Invertir LR (adelante↔atrás)", variable=invertir_lr_var,
               fg="white", bg=BG_APP, selectcolor=BG_APP, activebackground=BG_APP)\
  .grid(row=0, column=2, padx=(6,12))

detener_release_var = tk.BooleanVar(value=False)
tk.Checkbutton(opciones, text="Enviar 'detener' al soltar", variable=detener_release_var,
               fg="white", bg=BG_APP, selectcolor=BG_APP, activebackground=BG_APP)\
  .grid(row=0, column=3, padx=(6,12))

tk.Label(opciones, text="(Rate-limit 200ms • 3 reintentos)", fg="#cbd5e1", bg=BG_APP).grid(row=0, column=4)

# Contenedor 2 columnas
frm_mid = tk.Frame(root, bg=BG_APP)
frm_mid.pack(fill="both", expand=True, padx=10, pady=10)

# -------- Panel de control (izquierda) --------
frm_left = tk.Frame(frm_mid, width=CTRL_W, height=CTRL_H, bg=BG_APP)
frm_left.pack(side="left", padx=(0,10), pady=5)
frm_left.pack_propagate(False)

ctrl_canvas = tk.Canvas(frm_left, width=CTRL_W, height=CTRL_H-20, bg=BG_APP, highlightthickness=0)
ctrl_canvas.pack()
card_ctrl = rounded_card(CTRL_W, CTRL_H-20, int(22*SCALE))
ctrl_canvas.create_image(0, 0, image=card_ctrl, anchor="nw")
ctrl_canvas._assets = [card_ctrl]

flecha_arriba  = _ph_from_image_or_fallback(ruta_flecha_arriba,    (100,100), "up")
flecha_abajo   = _ph_from_image_or_fallback(ruta_flecha_abajo,     (100,100), "down")
flecha_derecha = _ph_from_image_or_fallback(ruta_flecha_derecha,   (100,100), "right")
flecha_izqda   = _ph_from_image_or_fallback(ruta_flecha_izquierda, (100,100), "left")
img_detener    = _ph_from_image_or_fallback(ruta_detener,          (400,100), "stop")

btn_up    = tk.Button(frm_left, image=flecha_arriba,  state="disabled", relief="flat", bd=0, cursor="hand2")
btn_down  = tk.Button(frm_left, image=flecha_abajo,   state="disabled", relief="flat", bd=0, cursor="hand2")
btn_right = tk.Button(frm_left, image=flecha_derecha, state="disabled", relief="flat", bd=0, cursor="hand2")
btn_left  = tk.Button(frm_left, image=flecha_izqda,   state="disabled", relief="flat", bd=0, cursor="hand2")
btn_stop  = tk.Button(frm_left, image=img_detener,    relief="flat", bd=0, cursor="hand2",
                      command=lambda: stop_all(send_hw=True))

btn_up.place(x=250, y=120)
btn_down.place(x=250, y=320)
btn_right.place(x=400, y=220)
btn_left.place(x=100, y=220)
btn_stop.place(x=90, y=470)

botones_mov = [btn_up, btn_down, btn_right, btn_left, btn_stop]

def set_controles(habilitar: bool):
    st = ("normal" if habilitar else "disabled")
    for b in botones_mov: b.config(state=st)

set_controles(False)

# -------- Simulador 3D (derecha) --------
frm_right = tk.Frame(frm_mid, bg=BG_APP)
frm_right.pack(side="left", padx=(10,0), pady=5)

btn_img = tk.Button(frm_right, text="Elegir imagen del carrito")
btn_img.pack(pady=(6,0))

cnv = tk.Canvas(frm_right, width=PANEL_SIZE, height=PANEL_SIZE, bg=BG_APP, highlightthickness=0)
cnv.pack(pady=8)

card_sim = rounded_card(PANEL_SIZE, PANEL_SIZE, int(22*SCALE))
cnv.create_image(0,0, image=card_sim, anchor="nw")
plane = draw_plane(cnv, PANEL_SIZE, PLANE_MARGIN, persp=PLANE_PERSPECT, n=GRID_N)
cnv._assets = [card_sim]

PLANE_CX = int((plane["TL"][0]+plane["TR"][0]+plane["BL"][0]+plane["BR"][0])/4)
PLANE_CY = int((plane["TL"][1]+plane["TR"][1]+plane["BL"][1]+plane["BR"][1])/4)

base_car_img, halo_img = load_car_sprite(IMG_PATH, SPRITE_W)
halo_ph  = ImageTk.PhotoImage(halo_img)
halo_id  = cnv.create_image(PLANE_CX, PLANE_CY, image=halo_ph)
cnv._assets.append(halo_ph)

car_ang = 0.0
car_img_ph, car_w, car_h = sprite_from_angle(base_car_img, car_ang)
car_id = cnv.create_image(PLANE_CX, PLANE_CY, image=car_img_ph)

info = tk.Label(frm_right, text="Flechas: mover/girar  |  Espacio: detener/soltar",
                fg="white", bg=BG_APP, font=("Segoe UI", 11))
info.pack(pady=(4,8))

def elegir_imagen():
    global base_car_img, halo_img, car_img_ph, car_w, car_h
    path = filedialog.askopenfilename(
        title="Elige la imagen del carrito",
        filetypes=[("Imágenes", "*.png;*.jpg;*.jpeg;*.bmp;*.webp")]
    )
    if not path: return
    base_car_img, halo_img = load_car_sprite(path, SPRITE_W)
    halo_ph_new = ImageTk.PhotoImage(halo_img)
    cnv.itemconfig(halo_id, image=halo_ph_new)
    cnv._assets.append(halo_ph_new)
    car_img_ph, car_w, car_h = sprite_from_angle(base_car_img, car_ang)
    cnv.itemconfig(car_id, image=car_img_ph)

btn_img.config(command=elegir_imagen)

# ---------- Distancia + Alerta objeto (sin frenar) ----------
ultra_ui = tk.Frame(frm_right, bg=BG_APP); ultra_ui.pack(pady=(0,6))
tk.Label(ultra_ui, text="Distancia:", fg="white", bg=BG_APP).grid(row=0, column=0, sticky="w")
dist_text = tk.StringVar(value="— cm")
lbl_dist = tk.Label(ultra_ui, textvariable=dist_text, fg="#38bdf8", bg=BG_APP, font=("Segoe UI", 14, "bold"))
lbl_dist.grid(row=0, column=1, padx=(6,14))
alerta_var = tk.BooleanVar(value=True)
tk.Checkbutton(ultra_ui, text="Alerta objeto <", variable=alerta_var,
               fg="white", bg=BG_APP, selectcolor=BG_APP, activebackground=BG_APP)\
  .grid(row=0, column=2)
umbral_var = tk.IntVar(value=25)
umbral_entry = tk.Entry(ultra_ui, width=4, textvariable=umbral_var); umbral_entry.grid(row=0, column=3)
tk.Label(ultra_ui, text="cm", fg="white", bg=BG_APP).grid(row=0, column=4, padx=(2,8))
beep_var = tk.BooleanVar(value=False)
tk.Checkbutton(ultra_ui, text="Beep", variable=beep_var,
               fg="white", bg=BG_APP, selectcolor=BG_APP, activebackground=BG_APP)\
  .grid(row=0, column=5)

# Estado grande
estado_ui = tk.Frame(frm_right, bg=BG_APP); estado_ui.pack(pady=(0,10))
tk.Label(estado_ui, text="Estado:", fg="white", bg=BG_APP).grid(row=0, column=0, sticky="w")
obj_text = tk.StringVar(value="Libre")
lbl_objeto = tk.Label(estado_ui, textvariable=obj_text, fg="#22c55e", bg=BG_APP, font=("Segoe UI", 16, "bold"))
lbl_objeto.grid(row=0, column=1, padx=(8,0), sticky="w")

ultra_job = None
objeto_presente = False

def _poll_ultrasonico():
    global ultra_job, objeto_presente
    if not estado["conectado"] or transport is None:
        dist_text.set("— cm"); lbl_dist.config(fg="#cbd5e1")
        obj_text.set("Libre"); lbl_objeto.config(fg="#94d82d")
        objeto_presente = False
        ultra_job = root.after(ULTRA_POLL_MS, _poll_ultrasonico); return
    try:
        d = transport.read_distance()
        if isinstance(d, (int,float)):
            dist_text.set(f"{d:.0f} cm"); lbl_dist.config(fg="#38bdf8")
            activo = bool(alerta_var.get())
            detecta = (d <= umbral_var.get()) if activo else False
            if detecta != objeto_presente and detecta and beep_var.get():
                root.bell()
            objeto_presente = detecta
            if detecta:
                obj_text.set("OBJETO"); lbl_objeto.config(fg="#f43f5e")
            else:
                obj_text.set("Libre");  lbl_objeto.config(fg="#22c55e")
        else:
            dist_text.set("— cm"); lbl_dist.config(fg="#cbd5e1")
            obj_text.set("Libre");  lbl_objeto.config(fg="#94d82d")
            objeto_presente = False
    except Exception:
        dist_text.set("— cm"); lbl_dist.config(fg="#cbd5e1")
        obj_text.set("Libre");  lbl_objeto.config(fg="#94d82d")
        objeto_presente = False
    ultra_job = root.after(ULTRA_POLL_MS, _poll_ultrasonico)

def _start_ultra_poll():
    global ultra_job
    if ultra_job is None:
        ultra_job = root.after(150, _poll_ultrasonico)

def _stop_ultra_poll():
    global ultra_job
    if ultra_job is not None:
        root.after_cancel(ultra_job); ultra_job = None
    dist_text.set("— cm"); lbl_dist.config(fg="#cbd5e1")
    obj_text.set("Libre");  lbl_objeto.config(fg="#94d82d")

# ------------------ Lógica de simulación y entrada ------------------
teclas = set(); MOV_KEYS = ("Up","Down","Left","Right")
u, v = 0.5, 0.5
lin_speed = 0.0; ang_speed = 0.0
V_FWD, V_BACK, W_LEFT, W_RIGHT = 0.35, -0.35, +90.0, -90.0

def get_cmd_for_key(k):
    modo = modo_var.get(); inv = invertir_lr_var.get()
    if modo == MODO_LR_FA:
        if k == "Left":   return "atras"    if inv else "adelante"
        if k == "Right":  return "adelante" if inv else "atras"
        if k == "Up":     return "girar_izquierda"
        if k == "Down":   return "girar_derecha"
    else:
        if k == "Up":     return "adelante"
        if k == "Down":   return "atras"
        if k == "Left":   return "girar_izquierda"
        if k == "Right":  return "girar_derecha"
    if k == "space":      return "detener"
    return None

def update_speeds():
    global lin_speed, ang_speed
    modo = modo_var.get()
    if modo == MODO_LR_FA:
        lin_speed = (V_FWD if "Left" in teclas else 0.0) + (V_BACK if "Right" in teclas else 0.0)
        ang_speed = (W_LEFT if "Up" in teclas else 0.0) + (W_RIGHT if "Down" in teclas else 0.0)
        if invertir_lr_var.get(): lin_speed = -lin_speed
    else:
        lin_speed = (V_FWD if "Up" in teclas else 0.0) + (V_BACK if "Down" in teclas else 0.0)
        ang_speed = (W_LEFT if "Left" in teclas else 0.0) + (W_RIGHT if "Right" in teclas else 0.0)

# Se construye con la función de envío de 'transport'
sender = CommandSender(
    sender_callable=lambda cmd: (transport and transport.send(cmd)) or False,
    on_soft_error=soft_warn,
    on_hard_disconnect=lambda m: on_desconectado(f"{m} (revisa conexión).")
)

def enviar_comando(cmd):
    if estado["conectado"] and transport:
        sender.queue(cmd)

def stop_all(send_hw=True):
    teclas.clear()
    if send_hw: enviar_comando("detener")

def key_down(e):
    k = e.keysym
    if k in MOV_KEYS:
        if k not in teclas:
            teclas.add(k)
            cmd = get_cmd_for_key(k)
            if cmd: enviar_comando(cmd)
    elif k == "space":
        stop_all(send_hw=True)

def key_up(e):
    k = e.keysym
    if k in MOV_KEYS and k in teclas:
        teclas.remove(k)
        if detener_release_var.get():
            enviar_comando("detener")

root.bind("<KeyPress>", key_down)
root.bind("<KeyRelease>", key_up)

def _btn_press(k):
    if k not in teclas:
        teclas.add(k)
        cmd = get_cmd_for_key(k)
        if cmd: enviar_comando(cmd)

def _btn_release(k):
    if k in teclas:
        teclas.remove(k)
        if detener_release_var.get():
            enviar_comando("detener")

btn_up.bind("<ButtonPress-1>",   lambda _e: _btn_press("Up"))
btn_up.bind("<ButtonRelease-1>", lambda _e: _btn_release("Up"))
btn_down.bind("<ButtonPress-1>",   lambda _e: _btn_press("Down"))
btn_down.bind("<ButtonRelease-1>", lambda _e: _btn_release("Down"))
btn_left.bind("<ButtonPress-1>",   lambda _e: _btn_press("Left"))
btn_left.bind("<ButtonRelease-1>", lambda _e: _btn_release("Left"))
btn_right.bind("<ButtonPress-1>",   lambda _e: _btn_press("Right"))
btn_right.bind("<ButtonRelease-1>", lambda _e: _btn_release("Right"))

# -------- Conectar --------
def do_connect():
    global transport
    modo = modo_conn.get()
    estado["modo"] = modo
    btn_conectar.config(state="disabled")
    try:
        if modo == "Wi-Fi":
            transport = HttpTransport(lambda: ent_ip.get())
        else:
            transport = BtTransport(lambda: ent_com.get())
        ok = transport.connect()
        if ok:
            on_conectado_ok()
        else:
            on_desconectado("No responde.")
    except Exception as e:
        on_desconectado(str(e))
    finally:
        btn_conectar.config(state="normal")

btn_conectar.config(command=do_connect)

# -------- Bucle del simulador --------
_last = time.time()
def step():
    global u, v, car_ang, car_img_ph, car_w, car_h, _last
    now = time.time(); dt = now - _last; _last = now
    update_speeds()
    if lin_speed or ang_speed:
        th = math.radians(car_ang)
        du = math.sin(th) * (lin_speed * dt)
        dv = -math.cos(th) * (lin_speed * dt)
        u = max(0.02, min(0.98, u + du))
        v = max(0.02, min(0.98, v + dv))
        car_ang = (car_ang + ang_speed * dt) % 360
        car_img_ph, car_w, car_h = sprite_from_angle(base_car_img, car_ang)
        cnv.itemconfig(car_id, image=car_img_ph)
    TL, TR, BL, BR = plane["TL"], plane["TR"], plane["BL"], plane["BR"]
    px, py = bilinear(TL, TR, BL, BR, u, v)
    cnv.coords(halo_id, px, py); cnv.coords(car_id, px, py)
    root.after(16, step)

# Crear canvas items después de sprite
car_img_ph, car_w, car_h = sprite_from_angle(base_car_img, 0)
car_id = cnv.create_image(PLANE_CX, PLANE_CY, image=car_img_ph)
root.after(16, step)
root.mainloop()